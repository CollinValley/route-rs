// Generated by route-rs-graphgen
// Source graph: examples/trivial-identity/src/pipeline.xml

use crate::packets::*;
use route_rs_runtime::link::primitive::*;
use route_rs_runtime::link::*;
use route_rs_runtime::processor::*;
use tokio::runtime;
use tokio::task::JoinHandle;

pub struct Pipeline {}

impl route_rs_runtime::pipeline::Runner for Pipeline {
    type Input = IntegerPacket;
    type Output = IntegerPacket;

    fn run(
        input_channel: crossbeam::Receiver<Self::Input>,
        output_channel: crossbeam::Sender<Self::Output>,
    ) {
        let mut all_runnables: Vec<TokioRunnable> = vec![];

        let elem_1_identity = Identity::new();

        let (mut runnables_1, mut egressors_1) =
            InputChannelLink::new().channel(input_channel).build_link();
        all_runnables.append(&mut runnables_1);
        let link_1_egress_0 = egressors_1.remove(0);

        let (mut runnables_2, mut egressors_2) = ProcessLink::new()
            .ingressor(link_1_egress_0)
            .processor(elem_1_identity)
            .build_link();
        all_runnables.append(&mut runnables_2);
        let link_2_egress_0 = egressors_2.remove(0);

        let (mut runnables_3, mut _egressors_3) = OutputChannelLink::new()
            .ingressor(link_2_egress_0)
            .channel(output_channel)
            .build_link();
        all_runnables.append(&mut runnables_3);

        let mut rt = runtime::Builder::new().threaded_scheduler().enable_all().build().unwrap();
        rt.block_on(async {
            let handles: Vec<JoinHandle<()>> = all_runnables.into_iter().map(tokio::spawn).collect();
            for handle in handles {
                handle.await.unwrap();
            }
        });
    }
}
